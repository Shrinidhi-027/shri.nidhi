<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ken Burns + Sliding Text (HTML)</title>
<style>
  :root{
    --w:1280px; --h:720px;
    --duration: 5000ms; /* animation duration */
  }
  html,body{height:100%; margin:0; display:flex; align-items:center; justify-content:center; background:#111;}
  .stage {
    position:relative;
    width:calc(var(--w));
    height:calc(var(--h));
    overflow:hidden;
    border-radius:12px;
    box-shadow:0 12px 40px rgba(0,0,0,.6);
    background: #000;
    user-select:none;
  }

  /* the image container - we'll scale it for the Ken Burns effect */
  .photo {
    position:absolute;
    inset:0;
    background-position:center;
    background-size:cover;
    transform-origin:center center;
    will-change:transform, filter;
    transition: none;
  }

  /* subtle vignette overlay */
  .vignette {
    position:absolute; inset:0; pointer-events:none;
    background:
      radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.35) 75%, rgba(0,0,0,0.6) 100%);
    mix-blend-mode:multiply;
  }

  /* caption box */
  .caption {
    position:absolute;
    left:50%;
    transform:translateX(-50%) translateY(20%);
    bottom: -120px; /* start off canvas */
    padding:14px 26px;
    border-radius:10px;
    backdrop-filter: blur(4px);
    display:inline-block;
    font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    font-weight:600;
    font-size:28px;
    color:#fff;
    box-shadow:0 6px 18px rgba(0,0,0,0.45);
    opacity:0;
    pointer-events:none;
  }

  /* text outline effect using text-shadow (lightweight) */
  .caption { text-shadow: 0 1px 0 rgba(0,0,0,.9), 0 0 6px rgba(0,0,0,.25); }

  /* animation classes — applied when user clicks "Play" or auto-start */
  .animate .photo {
    animation: zoomIn var(--duration) ease-in-out forwards;
  }
  .animate .caption {
    animation: slideUp var(--duration) cubic-bezier(.22,.9,.2,1) forwards;
    animation-delay: 450ms;
  }

  /* Keyframes */
  @keyframes zoomIn {
    0%   { transform: scale(1); filter:brightness(1.02) saturate(1.02); }
    50%  { transform: scale(1.03); }
    100% { transform: scale(1.06); filter:brightness(.98) saturate(.98); }
  }
  @keyframes slideUp {
    0% { transform: translateX(-50%) translateY(30%); bottom: -120px; opacity:0; }
    40% { bottom: calc(50% - 48px); opacity:1; transform: translateX(-50%) translateY(12%); }
    100% { bottom: calc(50% - 48px); opacity:1; transform: translateX(-50%) translateY(0%); }
  }

  /* UI */
  .controls { margin-top:18px; text-align:center; }
  button {
    cursor:pointer;
    font-weight:600;
    border:0; padding:10px 14px; border-radius:8px;
    background:#0b5fff; color:#fff;
    box-shadow:0 6px 18px rgba(11,95,255,.18);
    margin:0 6px;
  }
  button.secondary { background:#444; }
  a.download { display:inline-block; margin-left:8px; color:#0b5fff; text-decoration:none; font-weight:600; }
  small { color:#aaa; display:block; margin-top:8px; }
</style>
</head>
<body>

<!-- Replace src with your local image, or change via the UI -->
<div>
  <div class="stage" id="stage" aria-label="Animated photo">
    <div id="photo" class="photo" style="background-image:url('frame0.png');"></div>
    <div class="vignette"></div>
    <div class="caption" id="caption">Same like this — recreated</div>
  </div>

  <div class="controls">
    <button id="playBtn">Play</button>
    <button id="resetBtn" class="secondary">Reset</button>
    <button id="recordBtn">Record (WebM)</button>
    <a id="downloadLink" class="download" style="display:none;">Download</a>
    <small>Tip: To record, press <b>Record</b>, then <b>Play</b>. Recording will stop automatically at animation end.</small>
  </div>
</div>

<script>
(function(){
  const stage = document.getElementById('stage');
  const playBtn = document.getElementById('playBtn');
  const resetBtn = document.getElementById('resetBtn');
  const recordBtn = document.getElementById('recordBtn');
  const downloadLink = document.getElementById('downloadLink');
  const caption = document.getElementById('caption');

  const duration = 5000; // match CSS --duration in ms
  let recording = false;
  let mediaRecorder = null;
  let recordedChunks = [];

  function startAnimation() {
    // remove class then reflow to restart animation
    stage.classList.remove('animate');
    void stage.offsetWidth;
    stage.classList.add('animate');

    // stop recording automatically when animation ends
    setTimeout(() => {
      if (recording) stopRecording();
    }, duration + 200); // slightly after end
  }

  function resetAnimation() {
    stage.classList.remove('animate');
    // optionally force caption to hidden
    caption.style.opacity = '';
  }

  playBtn.addEventListener('click', () => {
    startAnimation();
  });

  resetBtn.addEventListener('click', resetAnimation);

  // Recording logic using canvas captureStream
  recordBtn.addEventListener('click', async () => {
    if (!recording) {
      // begin recording
      try {
        await startRecording();
      } catch(err) {
        alert('Recording failed: ' + err.message);
      }
    } else {
      stopRecording();
    }
  });

  async function startRecording(){
    // create a canvas sized to stage
    const w = stage.clientWidth;
    const h = stage.clientHeight;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');

    // We'll draw the stage into the canvas every frame using drawImage:
    // To draw the element we need to use <img> or background images; easiest is to create an Image object.
    // Extract the background-image URL from .photo
    const photoEl = document.getElementById('photo');
    const bg = window.getComputedStyle(photoEl).backgroundImage;
    const url = bg.slice(5, -2); // remove url("...")

    const img = new Image();
    img.src = url;
    await img.decode().catch(()=>{}); // ignore decode error

    // Prepare caption style values
    const font = window.getComputedStyle(caption).fontSize + " " + window.getComputedStyle(caption).fontFamily;
    ctx.font = font;
    ctx.textAlign = "center";

    // create stream and recorder
    const stream = canvas.captureStream(60); // 60fps capture
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
    recordedChunks = [];
    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size) recordedChunks.push(e.data);
    };
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.download = 'kenburns.webm';
      downloadLink.style.display = 'inline-block';
      downloadLink.textContent = 'Download video (WebM)';
    };

    // draw loop (sync with animation)
    let start = performance.now();
    let rafId;
    function draw(now) {
      const t = Math.min(1, (now - start) / duration); // 0..1
      // ease in-out (same as CSS cubic approximation)
      const ease = t < 0.5 ? 2*(t*t) : -1 + (4 - 2*t)*t;

      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // draw zoomed image: compute scale (1 -> 1.06)
      const scale = 1 + 0.06 * ease;
      const sw = canvas.width / scale;
      const sh = canvas.height / scale;
      const sx = (img.width - sw * (img.width / canvas.width)) / 2; // rough center sampling
      // simpler: draw centered scaled:
      ctx.save();
      // draw center-cropped scaled image
      // compute draw dimensions for cover behavior
      const imgRatio = img.width / img.height;
      const canvasRatio = canvas.width / canvas.height;
      let dw, dh;
      if (imgRatio > canvasRatio) {
        dh = canvas.height;
        dw = img.width * (canvas.height / img.height);
      } else {
        dw = canvas.width;
        dh = img.height * (canvas.width / img.width);
      }
      // zoom by scale
      dw *= scale;
      dh *= scale;
      ctx.drawImage(img, (canvas.width - dw)/2, (canvas.height - dh)/2, dw, dh);
      ctx.restore();

      // apply vignette overlay
      const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.height*0.1,
                                            canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/1.2);
      grad.addColorStop(0, 'rgba(0,0,0,0)');
      grad.addColorStop(0.5, 'rgba(0,0,0,0.25)');
      grad.addColorStop(1, 'rgba(0,0,0,0.6)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw caption background (semi-transparent rounded rect)
      const text = caption.textContent;
      ctx.font = "600 28px Inter, Roboto, Arial";
      const metrics = ctx.measureText(text);
      const padX = 18, padY = 12;
      const tw = metrics.width + padX*2;
      const th = 28 + padY*2;
      // caption position: slide from bottom to center area same ease curve
      const startY = canvas.height + 50;
      const endY = canvas.height*0.5 - 48;
      const cy = startY + (endY - startY) * ease;

      const cx = canvas.width/2 - tw/2;
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      roundRect(ctx, cx, cy - th + 8, tw, th, 10, true, false);

      // text with small shadow (black outline)
      ctx.fillStyle = 'black';
      ctx.fillText(text, canvas.width/2 + 1, cy - 8 + 1);
      ctx.fillStyle = 'white';
      ctx.fillText(text, canvas.width/2, cy - 8);

      // continue or stop
      if (now - start < duration) {
        rafId = requestAnimationFrame(draw);
      } else {
        cancelAnimationFrame(rafId);
      }
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (typeof r === 'undefined') r = 5;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y,   x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x,   y + h, r);
      ctx.arcTo(x,   y + h, x,   y,   r);
      ctx.arcTo(x,   y,   x + w, y,   r);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // Start recording and animation
    mediaRecorder.start();
    recording = true;
    recordBtn.textContent = 'Recording… (Click to stop)';
    downloadLink.style.display = 'none';
    start = performance.now();
    requestAnimationFrame(draw);
    startAnimation();
  }

  function stopRecording(){
    if (!recording) return;
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }
    recording = false;
    recordBtn.textContent = 'Record (WebM)';
  }

  // auto-play on load (optional)
  // startAnimation();

})();
</script>
</body>
</html>
